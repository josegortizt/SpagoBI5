/*
*
* @file ElementNodeVisitor.java
*
* Copyright (C) 2006-2009 Tensegrity Software GmbH
*
* This program is free software; you can redistribute it and/or modify it
* under the terms of the GNU General Public License (Version 2) as published
* by the Free Software Foundation at http://www.gnu.org/copyleft/gpl.html.
*
* This program is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
* more details.
*
* You should have received a copy of the GNU General Public License along with
* this program; if not, write to the Free Software Foundation, Inc., 59 Temple
* Place, Suite 330, Boston, MA 02111-1307 USA
*
* If you are developing and distributing open source applications under the
* GPL License, then you are free to use JPalo Modules under the GPL License.  For OEMs,
* ISVs, and VARs who distribute JPalo Modules with their products, and do not license
* and distribute their source code under the GPL, Tensegrity provides a flexible
* OEM Commercial License.
*
* @author Stepan Rutz
*
* @version $Id: ElementNodeVisitor.java,v 1.4 2009/04/29 10:21:57 PhilippBouillon Exp $
*
*/

/*
 * (c) Tensegrity Software 2005. All rights reserved.
 */
package org.palo.api;


/**
 * <code>ElementNodeVisitor</code>
 * 
 * Interface methods for an <code>ElementNodeVisitor</code>.
 * 
 * <p>
 * In a given dimension the elements are related to each other depending
 * on their consolidations. An element "Colors" could have three 
 * children "Red", "Green" and "Yellow". This forms a tree of the form
 * <pre>
 * Colors -+- Red
 *         |
 *         +- Green
 *         |
 *         +- Yellow
 * </pre>
 * 
 * A preorder traversal of this tree would result in the following order:
 * "Colors", "Red", "Green", "Yellow". (Parents are visited before
 * their children).
 * </p>
 * 
 * <p>
 * This class defines the signature for the callback that can be passed
 * to {@link org.palo.api.Dimension#visitElementTree(ElementNodeVisitor)}.
 * The pre-order traversal then happens automatically. As each element
 * is encountered the callback is invoked. For convenience the parent
 * node is also provided, but it is null for the roots elements.
 * </p>
 * 
 * <p>
 * Why use <code>ElementNode</code> and not <code>Element</code> directly ?
 * The reason is that an element can be consolidated multiple times within 
 * its parent dimension. So the elements can infact form a DAG
 * (Directed-Acyclic-Graph). An <code>ElementNode</code> wrapps an <code>Element</code>
 * and allows it to be retrieved by invoking the <code>getElement()</code> accessor.
 * The element-nodes are generated by the palo-api and form a tree (more accurately one
 * or more trees). This is sometimes more handy.
 * </p>
 * 
 * <p>
 * Example: Here is a function that prints out a dimension hierarchically
 * by means of an <code>ElementNodeVisitor</code>.
 * <pre>
 *    private static void dumpDimensionHierarchy(Dimension dimension)
 *    {
 *        System.err.println ("dumping dimension '" +
 *            dimension.getName() + "' in database '" +
 *            dimension.getDatabase().getName() + "' ...");
 *
 *        // the following code will "visit" the consolidation tree, that means
 *        // each node in the consolidation tree is processed in pre-order and
 *        // user-supplied callback of type ElementNodeVisitor is invoked
 *        // for each encountered node.
 *        
 *        dimension.visitElementTree(new ElementNodeVisitor() {
 *            public void visit(ElementNode elementNode, ElementNode parent)
 *            {
 *                // Retrieve the element nested in the current ElementNode
 *                Element element = elementNode.getElement();
 *                // Get depth
 *                int depth = element.getDepth();
 *                // indent according to depth
 *                for (int i = 0; i < depth; ++i)
 *                    System.err.print("    ");
 *                System.err.println(element.getName());
 *            }
 *        });
 *    }
 * </pre>
 * </p>
 * 
 * @author Stepan Rutz
 * @version $ID$
 */
public interface ElementNodeVisitor
{
    /**
     * Called during element-node visiting.
     * @param elementNode the current {@link ElementNode}.
     * @param parent the parent {@link ElementNode}, maybe <code>null</code>.
     */
    void visit(ElementNode elementNode, ElementNode parent);
}

